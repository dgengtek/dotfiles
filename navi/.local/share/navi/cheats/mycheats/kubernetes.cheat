% kubernetes, k8s

# display addresses of the control plane and services with label kubernetes.io/cluster-service=true
kubectl cluster-info

# set a default storageclass
kubectl patch storageclass <storageclass> -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

# get api server url
kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}'

# get authorization bearer token
kubectl get secret $(kubectl get serviceaccount default -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode

# delete a list of a resource with the given state
kubectl get <resource> -o json | jq -r '.items[] | select(.status.phase != "<state>") | .metadata.name' | xargs -n 1 kubectl delete <resource>

# select resources from a list with the given state for deletion
kubectl get <resource> -o json | jq -r '.items[] | select(.status.phase != "<state>") | .metadata.name' | fzf --multi | xargs -n 1 kubectl delete <resource>

# delete a single resource
kubectl delete <resource_object>

# operate on a resource object
kubectl <operation> <resource_object>

# change persistent volume policy
kubectl patch pv <pv-name> -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'

# Print the supported API resources on the server
kubectl api-resources

# debug and diagnose cluster problems
kubectl cluster-info dump

# Print all contexts
kubectl config get-contexts

# Print current context of kubeconfig
kubectl config current-context

# Set context of kubeconfig
kubectl config use-context <context>

# Print resource documentation
kubectl explain <resource>

# display node resource
kubectl get nodes --show-labels -o wide

# Get namespaces
kubectl get namespaces

# Get pods from namespace (add option '-o wide' for details)
kubectl get pods -n <namespace>

# Get pods from all namespace (add option '-o wide' for details)
kubectl get pods --all-namespaces

# allow scheduling on master
kubectl taint node <node> node-role.kubernetes.io/master:NoSchedule-

# get taints for each node
kubectl get nodes -o json | jq '.items[] | (.metadata.name , .spec)'

# restart a resource
kubectl rollout restart <resource>/<name>

# forcefully delete pod
kubectl delete pod <podname> --grace-period=0 --force

# wait for node
kubectl wait node/<nodename> --for=condition=Ready

# Get services from namespace
kubectl get services -n <namespace>

# Get details from resource on namespace
kubectl describe <resource>/<name> -n <namespace>

# Print logs from namespace
kubectl logs -f pods/<name> -n <namespace>

# Get deployments
kubectl get deployments -n <namespace>

# Edit deployments
kubectl edit deployment/<name> -n <namespace>

# Drain node in preparation for maintenance
kubectl drain <name>

# Mark node as schedulable
kubectl uncordon <name>

# Mark node as unschedulable
kubectl cordon <name>

# run a shell in a container on the cluster
kubectl run tmp-shell --restart=Never --rm -i --tty --image centos -- /bin/bash

# Display resource (cpu/memory/storage) usage
kubectl top <type>


$ resource: kubectl api-resources -o name
$ resource_object: kubectl get <resource> -o name
$ operation: echo -e 'get,explain,edit,delete' | tr ',' '\n'
